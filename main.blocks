<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable type="KIND_SpriteKind" id="lox9~+I?uR=b-_t[c8U(">EnemyTarget</variable><variable type="KIND_SpriteKind" id="uhv[#tbyUalS#B[`BP6t">GoodGuy</variable></variables><block type="pxt-on-start" id="IKce;ic^dFU{sVnzy.D|" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="fqZ)p-gmT_Lm83s8Xd_K" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Vector2 {" line1="    public x: number;" line2="    public y: number;" line3="    constructor(x: number, y: number) {" line4="        this.x = x;" line5="        this.y = y;" line6="    }" line7="    static distance(start: Vector2, end: Vector2) {" line8="        let xDist = end.x - start.x;" line9="        let yDist = end.y - start.y;" line10="        return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));" line11="    }" line12="}" numlines="13"></mutation><next><block type="typescript_statement" id="8)4moBwrVWqsCH029Tj}" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Node {" line1="    position: Vector2;" line2="    parent: Node;" line3="    G: int16;" line4="    constructor(position: Vector2, parent: Node) {" line5="        this.position = position;" line6="        this.parent = parent;" line7="        if (this.parent) {" line8="            this.G = this.parent.G + 1;" line9="        }" line10="    }" line11="}" numlines="12"></mutation><next><block type="typescript_statement" id="OyCPCJak#Yo-sH3B4mcd" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class NodeList {" line1="    list: Array&lt;Node&gt;;" line2="    constructor() {" line3="        this.list = [];" line4="    }" line5="    add(node: Node) {" line6="        this.list.push(node);" line7="    }" line8="    size() {" line9="        return this.list.length;" line10="    }" line11="    get(index: number) {" line12="        return this.list[index];" line13="    }" line14="    containsPosition(node: Vector2) {" line15="        for (let i = 0; i &lt; this.size(); i++) {" line16="            if (this.list[i].position.x == node.x &amp;&amp; this.list[i].position.y == node.y) {" line17="                return this.list[i];" line18="            }" line19="        }" line20="        return null;" line21="    }" line22="    removeElement(node: Node) {" line23="        let index = this.list.indexOf(node);" line24="        if (index != -1) {" line25="            this.list.removeAt(index);" line26="            return true;" line27="        }" line28="        return false;" line29="    }" line30="}" numlines="31"></mutation><next><block type="typescript_statement" id="J$=d^(q6;9JY:W$+vgQ=" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class PathFinder {" line1="    origin: Node;" line2="" line3="    map: tiles.TileMapData;" line4="    openList: NodeList;" line5="    closedList: NodeList;" line6="" line7="    constructor(origin: Vector2, map: tiles.TileMapData) {" line8="        this.origin = new Node(origin, null);" line9="        this.origin.G = 0;" line10="        this.map = map;" line11="    }" line12="" line13="    findPath(goal: Vector2) {" line14="        let showProcess = false;     //show Process" line15="        let width = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns);" line16="        let height = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows);" line17="        for (let x = 0; x &lt; width; x++) {" line18="            for (let y = 0; y &lt; height; y++) {" line19="                if (!this.map.isWall(x, y)) {" line20="                    tiles.setTileAt(tiles.getTileLocation(x, y), assets.tile`Background`);" line21="                }" line22="            }" line23="        }" line24="        this.openList = new NodeList();" line25="        this.closedList = new NodeList();" line26="        this.openList.add(this.origin);" line27="        let offsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];" line28="        while (this.openList.size() &gt; 0) {" line29="            let currentSquare: Node;" line30="            let lowestF = Infinity;" line31="            for (let j = 0; j &lt; this.openList.size(); j++) {" line32="                let F = this.calculateF(this.openList.get(j), goal);" line33="                if (F &lt; lowestF) {" line34="                    lowestF = F;" line35="                    currentSquare = this.openList.get(j);" line36="                }" line37="            }" line38="            this.openList.removeElement(currentSquare);" line39="            this.closedList.add(currentSquare);" line40="            if (showProcess) {" line41="                tiles.setTileAt(tiles.getTileLocation(currentSquare.position.x, currentSquare.position.y), assets.tile`Closed`);" line42="            }" line43="            for (let k = 0; k &lt; offsets.length; k++) {" line44="                let nodePos = new Vector2(currentSquare.position.x + offsets[k][0], currentSquare.position.y + offsets[k][1]);" line45="                let closed = this.closedList.containsPosition(nodePos);" line46="                if (this.getWalkable(nodePos) &amp;&amp; !closed) {" line47="                    let position = this.openList.containsPosition(nodePos);" line48="                    if (position) {" line49="                        if (currentSquare.G + 1 &lt; position.G) {" line50="                            position.parent = currentSquare;" line51="                            position.G = currentSquare.G + 1;" line52="                        }" line53="                    } else {" line54="                        this.openList.add(new Node(nodePos, currentSquare));" line55="                        if (showProcess) {" line56="                            tiles.setTileAt(tiles.getTileLocation(nodePos.x, nodePos.y), assets.tile`Open`);" line57="                        }" line58="                    }" line59="                }" line60="            }" line61="            let node = this.closedList.containsPosition(goal);" line62="            if (node != null) {" line63="                let path = [];" line64="                while (node.parent) {" line65="                    if (showProcess) {" line66="                        tiles.setTileAt(tiles.getTileLocation(node.position.x, node.position.y), assets.tile`BestPath`);" line67="                    }" line68="                    path.push(node.position);" line69="                    node = node.parent;" line70="                }" line71="                return path;" line72="            }" line73="        }" line74="        return null;" line75="    }" line76="" line77="    calculateF(node: Node, goal: Vector2) {" line78="        let G = node.G;" line79="        let H = Vector2.distance(node.position, goal);" line80="        return G + H;" line81="    }" line82="" line83="    getWalkable(position: Vector2) {" line84="        if (this.closedList.containsPosition(position)) {" line85="            return false;" line86="        }" line87="        if (this.map.isWall(position.x, position.y)) {" line88="            return false;" line89="        }" line90="        if (position.x &lt; 0 || position.x &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns)) {" line91="            return false;" line92="        }" line93="        if (position.y &lt; 0 || position.y &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows)) {" line94="            return false;" line95="        }" line96="" line97="        return true;" line98="    }" line99="}" numlines="100"></mutation><next><block type="typescript_statement" id="IiEfXw#g8dRk3SU*!M6m" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Enemy {" line1="    sprite: Sprite;" line2="    currentTarget: Sprite;" line3="    pathfinder: PathFinder;" line4="    constructor(column: number, row: number, tilemap: tiles.TileMapData) {" line5="        this.sprite = sprites.create(assets.image`enemyIMG`, SpriteKind.Enemy);" line6="        tiles.placeOnTile(this.sprite, tiles.getTileLocation(column, row))" line7="        this.currentTarget = sprites.create(assets.image`enemyTargetIMG`, SpriteKind.EnemyTarget);" line8="        tiles.placeOnTile(this.currentTarget, tiles.getTileLocation(column, row));" line9="        this.currentTarget.setFlag(SpriteFlag.Invisible, true);    // show hint" line10="        this.pathfinder = new PathFinder(new Vector2(column, row), tilemap);" line11="        this.sprite.follow(this.currentTarget);" line12="    }" line13="    updatePath(goal: Vector2) {" line14="        if (this.currentTarget.tilemapLocation().col != goal.x || this.currentTarget.tilemapLocation().row != goal.y) {" line15="            this.pathfinder.origin.position = new Vector2(this.currentTarget.tilemapLocation().col, this.currentTarget.tilemapLocation().row);" line16="            let path2 = this.pathfinder.findPath(goal);" line17="            let next = path2[path2.length - 1];" line18="            tiles.placeOnTile(this.currentTarget, tiles.getTileLocation(next.x, next.y));" line19="        }" line20="    }" line21="    pathFind(target: Sprite) {" line22="        if (Vector2.distance(new Vector2(this.sprite.x, this.sprite.y), new Vector2(this.currentTarget.x, this.currentTarget.y)) &lt; 5) {" line23="            this.updatePath(new Vector2(target.tilemapLocation().col, target.tilemapLocation().row));" line24="        }" line25="    }" line26="    setRandomPosition() {" line27="        tiles.placeOnRandomTile(this.sprite, assets.tile`Background`);" line28="        this.currentTarget.setPosition(this.sprite.x, this.sprite.y);" line29="    }" line30="}" numlines="31"></mutation></block></next></block></next></block></next></block></next></block></statement></block></xml>