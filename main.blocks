<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable type="KIND_SpriteKind" id="@mKt5O86sb,%Wb8@`pXU">EnemyTarget</variable><variable type="KIND_SpriteKind" id="lvLmBB@bau$$MbqZJZ21">GoodGuy</variable></variables><block type="pxt-on-start" id="F}#jnNbl_!hVz^B@XsPV" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="l9ainO?XJWsm#|V3W54?" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Vector2 {&#13;" line1="    public x: number;&#13;" line2="    public y: number;&#13;" line3="    constructor(x: number, y: number) {&#13;" line4="        this.x = x;&#13;" line5="        this.y = y;&#13;" line6="    }&#13;" line7="    static distance(start: Vector2, end: Vector2) {&#13;" line8="        let xDist = end.x - start.x;&#13;" line9="        let yDist = end.y - start.y;&#13;" line10="        return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));&#13;" line11="    }&#13;" line12="}" numlines="13"></mutation><next><block type="typescript_statement" id="SX`]tYstfT}{aQJByf8]" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Node {&#13;" line1="    position: Vector2;&#13;" line2="    parent: Node;&#13;" line3="    G: int16;&#13;" line4="    constructor(position: Vector2, parent: Node) {&#13;" line5="        this.position = position;&#13;" line6="        this.parent = parent;&#13;" line7="        if (this.parent) {&#13;" line8="            this.G = this.parent.G + 1;&#13;" line9="        }&#13;" line10="    }&#13;" line11="}" numlines="12"></mutation><next><block type="typescript_statement" id="R81m:Aejmbc4j*5E*Jji" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class NodeList {&#13;" line1="    list: Array&lt;Node&gt;;&#13;" line2="    constructor() {&#13;" line3="        this.list = [];&#13;" line4="    }&#13;" line5="    add(node: Node) {&#13;" line6="        this.list.push(node);&#13;" line7="    }&#13;" line8="    size() {&#13;" line9="        return this.list.length;&#13;" line10="    }&#13;" line11="    get(index: number) {&#13;" line12="        return this.list[index];&#13;" line13="    }&#13;" line14="    containsPosition(node: Vector2) {&#13;" line15="        for (let i = 0; i &lt; this.size(); i++) {&#13;" line16="            if (this.list[i].position.x == node.x &amp;&amp; this.list[i].position.y == node.y) {&#13;" line17="                return this.list[i];&#13;" line18="            }&#13;" line19="        }&#13;" line20="        return null;&#13;" line21="    }&#13;" line22="    removeElement(node: Node) {&#13;" line23="        let index = this.list.indexOf(node);&#13;" line24="        if (index != -1) {&#13;" line25="            this.list.removeAt(index);&#13;" line26="            return true;&#13;" line27="        }&#13;" line28="        return false;&#13;" line29="    }&#13;" line30="}" numlines="31"></mutation><next><block type="typescript_statement" id="A=K@(e}S**HCZLh[?zkR" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class PathFinder {&#13;" line1="    origin: Node;&#13;" line2="    sprite: Sprite;&#13;" line3="    followTarget: Sprite;&#13;" line4="&#13;" line5="    map: tiles.TileMapData;&#13;" line6="    openList: NodeList;&#13;" line7="    closedList: NodeList;&#13;" line8="&#13;" line9="    constructor(map: tiles.TileMapData) {&#13;" line10="        this.origin.G = 0;&#13;" line11="        this.map = map;&#13;" line12="    }&#13;" line13="&#13;" line14="    attachSprite(sprite: Sprite) {&#13;" line15="        this.sprite = sprite;&#13;" line16="    }&#13;" line17="&#13;" line18="    updatePathfinding(target: Sprite) {&#13;" line19="        this.origin = new Node(new Vector2(this.sprite.x, this.sprite.y), null);&#13;" line20="        if (Vector2.distance(new Vector2(this.followTarget.x, this.followTarget.y), new Vector2(this.sprite.x, this.sprite.y)) &lt; 5) {&#13;" line21="            let path = this.findPath(new Vector2(target.tilemapLocation().col, target.tilemapLocation().row));&#13;" line22="            let next = path[path.length-1];&#13;" line23="            this.followTarget.setPosition(next.x, next.y);&#13;" line24="        }&#13;" line25="    }&#13;" line26="&#13;" line27="    findPath(goal: Vector2) {&#13;" line28="        let showProcess = false;     //show Process&#13;" line29="        let width = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns);&#13;" line30="        let height = tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows);&#13;" line31="        for (let x = 0; x &lt; width; x++) {&#13;" line32="            for (let y = 0; y &lt; height; y++) {&#13;" line33="                if (!this.map.isWall(x, y)) {&#13;" line34="                    tiles.setTileAt(tiles.getTileLocation(x, y), assets.tile`Background`);&#13;" line35="                }&#13;" line36="            }&#13;" line37="        }&#13;" line38="        this.openList = new NodeList();&#13;" line39="        this.closedList = new NodeList();&#13;" line40="        this.openList.add(this.origin);&#13;" line41="        let offsets = [[1, 0], [-1, 0], [0, 1], [0, -1]];&#13;" line42="        while (this.openList.size() &gt; 0) {&#13;" line43="            let currentSquare: Node;&#13;" line44="            let lowestF = Infinity;&#13;" line45="            for (let j = 0; j &lt; this.openList.size(); j++) {&#13;" line46="                let F = this.calculateF(this.openList.get(j), goal);&#13;" line47="                if (F &lt; lowestF) {&#13;" line48="                    lowestF = F;&#13;" line49="                    currentSquare = this.openList.get(j);&#13;" line50="                }&#13;" line51="            }&#13;" line52="            this.openList.removeElement(currentSquare);&#13;" line53="            this.closedList.add(currentSquare);&#13;" line54="            if (showProcess) {&#13;" line55="                tiles.setTileAt(tiles.getTileLocation(currentSquare.position.x, currentSquare.position.y), assets.tile`Closed`);&#13;" line56="            }&#13;" line57="            for (let k = 0; k &lt; offsets.length; k++) {&#13;" line58="                let nodePos = new Vector2(currentSquare.position.x + offsets[k][0], currentSquare.position.y + offsets[k][1]);&#13;" line59="                let closed = this.closedList.containsPosition(nodePos);&#13;" line60="                if (this.getWalkable(nodePos) &amp;&amp; !closed) {&#13;" line61="                    let position = this.openList.containsPosition(nodePos);&#13;" line62="                    if (position) {&#13;" line63="                        if (currentSquare.G + 1 &lt; position.G) {&#13;" line64="                            position.parent = currentSquare;&#13;" line65="                            position.G = currentSquare.G + 1;&#13;" line66="                        }&#13;" line67="                    } else {&#13;" line68="                        this.openList.add(new Node(nodePos, currentSquare));&#13;" line69="                        if (showProcess) {&#13;" line70="                            tiles.setTileAt(tiles.getTileLocation(nodePos.x, nodePos.y), assets.tile`Open`);&#13;" line71="                        }&#13;" line72="                    }&#13;" line73="                }&#13;" line74="            }&#13;" line75="            let node = this.closedList.containsPosition(goal);&#13;" line76="            if (node != null) {&#13;" line77="                let path2 = [];&#13;" line78="                while (node.parent) {&#13;" line79="                    if (showProcess) {&#13;" line80="                        tiles.setTileAt(tiles.getTileLocation(node.position.x, node.position.y), assets.tile`BestPath`);&#13;" line81="                    }&#13;" line82="                    path2.push(node.position);&#13;" line83="                    node = node.parent;&#13;" line84="                }&#13;" line85="                return path2;&#13;" line86="            }&#13;" line87="        }&#13;" line88="        return null;&#13;" line89="    }&#13;" line90="&#13;" line91="    calculateF(node: Node, goal: Vector2) {&#13;" line92="        let G = node.G;&#13;" line93="        let H = Vector2.distance(node.position, goal);&#13;" line94="        return G + H;&#13;" line95="    }&#13;" line96="&#13;" line97="    getWalkable(position: Vector2) {&#13;" line98="        if (this.closedList.containsPosition(position)) {&#13;" line99="            return false;&#13;" line100="        }&#13;" line101="        if (this.map.isWall(position.x, position.y)) {&#13;" line102="            return false;&#13;" line103="        }&#13;" line104="        if (position.x &lt; 0 || position.x &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Columns)) {&#13;" line105="            return false;&#13;" line106="        }&#13;" line107="        if (position.y &lt; 0 || position.y &gt;= tileUtil.tilemapProperty(this.map, tileUtil.TilemapProperty.Rows)) {&#13;" line108="            return false;&#13;" line109="        }&#13;" line110="&#13;" line111="        return true;&#13;" line112="    }&#13;" line113="}" numlines="114"></mutation><next><block type="typescript_statement" id=",}ueH#6C_%7dB%S0I+t~" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Enemy {&#13;" line1="    sprite: Sprite;&#13;" line2="    currentTarget: Sprite;&#13;" line3="    pathfinder: PathFinder;&#13;" line4="    constructor(column: number, row: number, tilemap: tiles.TileMapData) {&#13;" line5="        this.sprite = sprites.create(assets.image`enemyIMG`, SpriteKind.Enemy);&#13;" line6="        tiles.placeOnTile(this.sprite, tiles.getTileLocation(column, row))&#13;" line7="        this.currentTarget = sprites.create(assets.image`enemyTargetIMG`, SpriteKind.EnemyTarget);&#13;" line8="        tiles.placeOnTile(this.currentTarget, tiles.getTileLocation(column, row));&#13;" line9="        this.currentTarget.setFlag(SpriteFlag.Invisible, true);    // show hint&#13;" line10="        this.pathfinder = new PathFinder(tilemap);&#13;" line11="        this.sprite.follow(this.currentTarget);&#13;" line12="    }&#13;" line13="    updatePath(goal: Vector2) {&#13;" line14="        if (this.currentTarget.tilemapLocation().col != goal.x || this.currentTarget.tilemapLocation().row != goal.y) {&#13;" line15="            this.pathfinder.origin.position = new Vector2(this.currentTarget.tilemapLocation().col, this.currentTarget.tilemapLocation().row);&#13;" line16="            let path22 = this.pathfinder.findPath(goal);&#13;" line17="            let next2 = path22[path22.length - 1];&#13;" line18="            tiles.placeOnTile(this.currentTarget, tiles.getTileLocation(next2.x, next2.y));&#13;" line19="        }&#13;" line20="    }&#13;" line21="    pathFind(target: Sprite) {&#13;" line22="        if (Vector2.distance(new Vector2(this.sprite.x, this.sprite.y), new Vector2(this.currentTarget.x, this.currentTarget.y)) &lt; 5) {&#13;" line23="            this.updatePath(new Vector2(target.tilemapLocation().col, target.tilemapLocation().row));&#13;" line24="        }&#13;" line25="    }&#13;" line26="    setRandomPosition() {&#13;" line27="        tiles.placeOnRandomTile(this.sprite, assets.tile`Background`);&#13;" line28="        this.currentTarget.setPosition(this.sprite.x, this.sprite.y);&#13;" line29="    }&#13;" line30="}" numlines="31"></mutation></block></next></block></next></block></next></block></next></block></statement></block></xml>